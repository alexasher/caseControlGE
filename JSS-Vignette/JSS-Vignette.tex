\documentclass[nojss]{jss}
\usepackage[utf8]{inputenc}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\author{
Alex Asher\\Texas A\&M University
}
\title{Semiparametric Analysis of Polygenic Gene-Environment Interactions in
Case-Control Studies with \pkg{caseControlGE}}

\Plainauthor{Alex Asher}
\Plaintitle{Semiparametric Analysis of Polygenic Gene-Environment Interactions in
Case-Control Studies with caseControlGE}
\Shorttitle{\pkg{caseControlGE}: Gene-Environment Interactions in Case-Control
Studies}

\Abstract{
Gene-environment interactions can be efficiently estimated in
case-control data by exploiting the assumption of gene-environment
independence in the source population, but until recently such
techniques required parametric modelling of the genetic variables. The
\pkg{caseControlGE} package implements the methods of
\citeauthor{Stalder2017} (2017, \emph{Biometrika}, \textbf{104},
801-812) and \citeauthor{Wang2018unpublished} (2018, unpublished), which
exploit the assumption of gene-environment independence without placing
any assumptions on the marginal distributions of the genetic and
environmental variables. These methods are ideally suited for analysis
of complex polygenic data for which parametric distributional models are
not feasible. In addition to the two estimators, the package also
supplies a function to simulate case-control data and several helper
functions for use on model objects. Use of this package is illustrated
using simulated data from a case-control study of breast cancer.
}

\Keywords{case-control study; gene-environment interaction; genetic epidemiology;
retrospective method; semiparametric analysis; pseudolikelihood;
polygenic analysis}
\Plainkeywords{case-control study; gene-environment interaction; genetic epidemiology;
retrospective method; semiparametric analysis; pseudolikelihood;
polygenic analysis}

%% publication information
%% \Volume{50}
%% \Issue{9}
%% \Month{June}
%% \Year{2012}
%% \Submitdate{}
%% \Acceptdate{2012-06-04}

\Address{
    Alex Asher\\
  Texas A\&M University\\
  Department of Statistics\\
  E-mail: \email{alexasher@stat.tamu.edu}\\
  
  }

\usepackage{amsmath}

\begin{document}

\begin{titlepage}
\end{titlepage}

\def\bbeta{\mbox{\boldmath $\beta$}} \def\pr{\hbox{pr}}

\section{Introduction}

\subsection{caseControlGE package}

The \pkg{caseControlGE} package \citep{Asher2018R} contains tools for
the analysis of case-control data using \proglang{R} \citep{R2018}. It
implements the methods of \citet{Stalder2017} and
\citet{Wang2018unpublished}, both of which fall under the class of
semiparametric retrospective profile likelihood estimators. These
methods are the first available to exploit the assumption of
gene-environment independence while treating the genetic component
nonparametrically. As such, they are well suited to replace logistic
regression as the preferred method in situations where parametric
distributional models are not feasible, such as in the analysis of
complex polygenic data.

\pkg{caseControlGE} contains three main functions: \code{simulateCC},
\code{spmle}, and \code{spmleCombo}, as well as several helper
functions. Section \ref{sec:simulateCC} of this paper introduces
\code{simulateCC} in the context of simulating case-control data
analogous to the data analyzed in \cite{Wang2018unpublished}. Section
\ref{sec:spmle} introduces \code{spmle} as a tool to analyze the
simulated data, and section \ref{sec:spmleCombo} introduces
\code{spmleCombo} to conduct a more efficient analysis of the simulated
data.

\subsection{Background}

Case-control studies are retrospective observational studies in which
the sample consists of a group of healthy subjects and a group of
diseased subjects. A crucial aspect of the case-control design is that
the outcome, disease status, is known \emph{before} sampling. The
ability to deliberately oversample diseased subjects makes the
case-control design cost effective, which is why it is widely popular in
studies of gene-environment interactions.

Given the genetic and environmental covariates \(G\) and \(E\), we
assume the risk of disease \(D\) in the underlying population follows
the model \[ \pr(D=1 \mid G,X) = H\{\alpha_0 + m(G,X,\bbeta)\}, \] where
\(H(x)=\{ 1 + \exp(-x)\}^{-1}\) is the logistic distribution function
and \(m(G,X,\bbeta)\) is a function that describes the joint effect of
\(G\) and \(X\) and is known up to the unspecified parameters of
interest \(\bbeta\).

Given the retrospective nature of case-control sampling, it is
surprising that standard prospective logistic regression can be used to
obtain unbiased estimates of \(\bbeta\) \citep{PrenticePyke1979}.
Logistic regression requires no assumptions about the joint distribution
of \(G\) and \(E\), but it suffers from low power when estimating
\(G * E\) interaction effects. To gain efficiency,
\citet{ChatterjeeCarroll2005} exploited the assumption of
gene-environment independence in the source population to maximize the
retrospective likelihood while profiling out the distribution of \(E\).
Their method is available as the function \code{snp.logistic} in the
\emph{Bioconductor} package \pkg{CGEN} \citep{CGEN2012}.

The method of \citeauthor{ChatterjeeCarroll2005}, and subsequent methods
utilizing the same retrospective profile likelihood framework, require a
parametric model for the distribution of \(G\) given \(E\). This becomes
difficult as the number and complexity of genetic variables in the model
grows. Capitalizing on advances in high-throughput genomics, genome-wide
association studies have identified scores of SNPs associated with
complex diseases such as cancers and diabetes. Modern case-control
studies of gene-environment interactions need efficient methodology that
allows for a flexible and arbitrarily complex genetic component, such as
multiple correlated SNPs and/or continuous polygenic risk scores (PRSs).

The method of \citet{Stalder2017} extends the retrospective profile
likelihood framework of \citeauthor{ChatterjeeCarroll2005}, dispensing
with the need to model \(G\) parametrically. When the population disease
rate \(\pi_1\) is known, the retrospective profile loglikelihood can be
estimated (up to an additive constant) using just the case-control
sample and without modeling the distribution of \(G\). When \(\pi_1\) is
unknown but the disease is rare, estimates can be obtained using the
\emph{rare disease approximation} that \(\pi_1 \approx 0\), which
typically introduces negligible bias \citep{Stalder2017}.

\citet{Wang2018unpublished} proposed an improvement to the method of
\citet{Stalder2017} that increases the efficiency of the estimates with
no additional assumptions. This development relies on the observation
that the method of \citeauthor{Stalder2017} removes dependence on the
distribution of the genetic and environmental variables in two different
fashions; by treating the genetic and environmental variables
symmetrically \citeauthor{Wang2018unpublished} generate two sets of
parameter estimates that are combined to generate a more efficient
estimate.

\subsection{Implementation}

The semiparametric method of \citet{Stalder2017} is implemented as the
function \code{spmle} in \pkg{caseControlGE}, detailed in section
\ref{sec:spmle}. Estimating the semiparametric profile likelihood is a
computationally intensive process, and significant effort was invested
in speeding up calculations. Estimation functions, including the
analytic gradient and hessian, are written in C++ and compiled using
\pkg{Rcpp} \citep{Eddelbuettel2013Rcpp}, providing a tremendous speedup
over native \proglang{R} code. Extensive benchmarking and code profiling
was conducted, and estimation functions were written to apply matrix
operations to contiguous memory locations whenever possible, reducing
memory latency and allowing modern processors to exploit data level
parallelism and perform the same operation on multiple data points
simultaneously.

The estimated semiparametric likelihood is maximized using the
quasi-Newton optimizer \pkg{ucminf} \citep{Nielsen2016ucminf} using
starting values from logistic regression. \code{ucminf} is particularly
well suited for this application because it allows us to precondition
the optimization with the analytic hessian, and it evaluates the
gradient after each call to the objective function. Calculating the
gradient along with the likelihood adds negligable computational
complexity, so we call a single C++ function to compute them both, then
return them separately to \code{ucminf}. This leads \code{ucminf} to
converge in roughly half the time of the next-fastest optimizers
(several of the various \proglang{R} implementations of the BFGS
algorithm tie for second place). The unmatched speed of \code{ucminf}
means we are willing to tolerate its bugs, which include occasionally
declaring convergence before actually converging. To address this,
\code{spmle} checks the gradient at the reported optimum and restarts
the optimization if necessary (with different starting values).

Computational complexity of the asymptotic covariance estimation, which
contains a sum of the form
\(\sum_{i=1}^{n} \: \sum_{j=1}^{n} \: \sum_{k=1}^{n} \partial {\cal L}_{ijk}(\Omega) / \partial \Omega\),
was reduced from \(O(n^3)\) to \(O(n^2)\) by storing intermediate values
in a three-dimensional array. This increases speed at the cost of memory
usage, which climbs from \(O(n)\) to \(O(n^2)\), setting a practical
limit on sample size in the low tens of thousands for average personal
computers. This is sufficient to analyze all but the largest
case-control studies; covariance estimates for larger studies should be
computed using the bootstrap.

Asymptotic covariance estimates for the Symmetric Combination Estimator
of \citeauthor{Wang2018unpublished} converge slowly and unreliable in
practice, often providing poor coverage.
\citeauthor{Wang2018unpublished} recommend a balanced bootstrap, with
cases and controls resampled separately, to estimate covariance.
\pkg{caseControlGE} offers users with multicore computers the option to
speed up computation by using multiple processors. Parallelization is
implemented using the \proglang{R} base package \pkg{parallel}, which is
installed by default on all operating systems. Parallelization on
computers running Linux or macOS is done by forking the active
\proglang{R} session, saving time and memory. This option is unavailable
in Windows, so parallelization is fractionally slower because a PSOCK
cluster is created with a new instance of \proglang{R} running on each
core.

\section{Simulating case-control data with simulateCC} \label{sec:simulateCC}

\cite{Wang2018unpublished} demonstrate the utility of their method

\begin{CodeChunk}

\begin{CodeInput}
R> 1
\end{CodeInput}

\begin{CodeOutput}
[1] 1
\end{CodeOutput}
\end{CodeChunk}

\section{Analyzing case-control data with spmle} \label{sec:spmle}

\begin{CodeChunk}

\begin{CodeInput}
R> 1
\end{CodeInput}

\begin{CodeOutput}
[1] 1
\end{CodeOutput}
\end{CodeChunk}

\section{Analyzing case-control data with spmleCombo} \label{sec:spmleCombo}

\bibliography{RJCrefs_05-30-2018}



\end{document}

