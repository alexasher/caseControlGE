% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimation_functions.R
\name{spmle}
\alias{spmle}
\title{Semiparametric Maximum Pseudolieklihood Estimator for Case-Control Studies Under G-E Independence.}
\usage{
spmle(D, G, E, pi1, data, control = list(), swap = FALSE, startvals)
}
\arguments{
\item{D}{a binary vector of disease status (1=case, 0=control).}

\item{G}{a vector or matrix (if multivariate) containing genetic data. Can be continuous, discrete, or a combination.}

\item{E}{a vector or matrix (if multivariate) containing environmental data. Can be continuous, discrete, or a combination.}

\item{pi1}{the population disease rate, a scalar in [0, 1) or the string "rare".  Using \code{pi1=0} is the rare disease approximation.}

\item{data}{an optional data frame, list, or environment (or object coercible by \code{\link[base]{as.data.frame}}
to a data frame) containing the variables in the model.  If not found in data, the variables are taken from
the environment from which \code{spmle} is called.}

\item{control}{a list of control parameters that allow the user to control the optimization algorithm.  See 'Details'.}

\item{swap}{a logical scalar rarely of interest to the end user.  Dependence on the distributions of G and E
are removed using different methods; this switch swaps them to produce a symmetric estimator with identical
properties to the SPMLE.  Default \code{FALSE}.}

\item{startvals}{an optional numeric vector of coefficient starting values for optimization.  Usually left blank,
in which case logistic regression estimates are used as starting values.}
}
\value{
an object of class \code{spmle}.
}
\description{
\code{spmle} maximizes the retrospective pseudolikelihood of case-control data under the assumption
of G-E independence in the underlying population.
The marginal distributions of G and E are treated nonparametrically.
}
\details{
This function applies the method of Stalder et. al. (2017) to maximize the
retrospective pseudolikelihood of case-control data under the assumption of G-E independence.
It currently supports the model with G and E main effects, and a multiplicative G*E interaction.

The \code{control} argument is a list that controls the behavior of the optimization algorithm
\code{\link[ucminf]{ucminf}} from the \pkg{ucminf} package.  When \code{ucminf} works,
it works brilliantly (typically more than twice as fast as the next-fastest algorithm).
But it has a nasty habit of declaring convergence before actually converging.
To address this, \code{spmle} checks the maximum gradient at "convergence", and can rerun the optimization
using different starting values.  The \code{control} argument can supply any of the following components:
\describe{
  \item{\code{max_grad_tol}}{maximum allowable gradient at convergence.  \code{spmle} does not
    consider the optimization to have converged if the maximum gradient \code{> max_grad_tol}.
    Default \code{max_grad_tol = 0.001}.}
  \item{\code{num_retries}}{number of times to retry optimization.  An error is produced if
    the optimization has not converged after \code{num_retries}.  Different starting values
    are used for each retry.  Default \code{num_retries = 2}.}
  \item{\code{use_hess}}{a logical value instructing \code{spmle} to use the analytic hessian
    to precondition the optimization.  This brings significant speed benefits, and is one reason
    \code{ucminf} is so fast.  For unknown reasons, preconditioning causes computers with
    certain Intel CPUs to prematurely terminate iterating.  By default, \code{use_hess = TRUE},
    but if you notice that \code{ucminf} never converges during the first attempt, try setting \code{use_hess = FALSE}.}
  \item{\code{trace}}{a scalar or logical value that is used by both \code{spmle} and \code{ucminf}
    to control the printing of detailed tracing information.
    If TRUE or >0, details of each \code{ucminf} iteration are printed.
    If FALSE or 0, \code{ucminf} iteration details are suppressed but \code{spmle} still
    prints optimization retries.  If \code{trace < 0} nothing is printed.  Default \code{trace = 0}.}
  \item{additional control parameters}{not used by \code{spmle}, but are passed to \code{\link[ucminf]{ucminf}}.
    Note that the \code{ucminf} algorithm has four stopping criteria, and \code{ucminf} will
    declare convergence if any one of them has been met.  The \code{ucminf} control parameter
    "\code{grtol}" controls \code{ucminf}'s gradient stopping criterion, which defaults to
    \code{1e-6}.  \code{grtol} should not be set larger than the \code{spmle} control parameter \code{max_grad_tol}.}
}
}
\examples{
# Simulation from Table 1 in Stalder et. al. (2017)
dat = simulate_complex(ncase=1000,
                       ncontrol=1000,
                       beta0=-4.14,
                       betaG_SNP=c(log(1.2), log(1.2), 0, log(1.2), 0),
                       betaE_bin=log(1.5),
                       betaGE_SNP_bin=c(log(1.3), 0, 0, log(1.3), 0),
                       MAF=c(0.1, 0.3, 0.3, 0.3, 0.1),
                       SNP_cor=0.7,
                       E_bin_freq=0.5)

# SPMLE with known population disease rate of 0.03
spmle(D=dat$D, G=dat$G, E=dat$E, pi1=0.03)

# Simulation with a single SNP and a single binary environmental variable.
# True population disease rate in this simulation is 0.03.
# This simulation scenario was used in the Supplementary Material of Stalder et. al. (2017)
# to compare performance against the less flexible method of Chatterjee and Carroll (2005),
# which is available as the function as snp.logistic in the Bioconductor package CGEN.
dat = simulate_complex(ncase=100,
                       ncontrol=100,
                       beta0=-3.77,
                       betaG_SNP=log(1.2),
                       betaE_bin=log(1.5),
                       betaGE_SNP_bin=log(1.3),
                       MAF=0.1)

# SPMLE using the rare disease assumption
#and with bootstrap SE, no tracing, and no hessian preconditioning.
spmle(D=dat$D, G=dat$G, E=dat$E, pi1=0, control=list(nboot=100, trace=0, use_hess=TRUE))
}
\seealso{
\code{\link{simulate_complex}} to simulate data
}
